require 'interview_questions'

# The factorial of a number is given by the formula:
#       factorial(n) = 1*...*(n-2)*(n-1)*n

describe '#factorial_loop' do
    # Write a function that calculates the factorial of a number, n, using a loop.

    it 'calculates correct factorials' do
        expect(Interview.factorial_loop(1)).to eq(1)
        expect(Interview.factorial_loop(3)).to eq(6)
        expect(Interview.factorial_loop(5)).to eq(120)
    end
end

# We can also calculate a factorial using recursion. One way to solve a
# problem recursively is to start by considering the "base case(s)" -- the
# easiest possible form of a problem. After figuring out what the base case
# is, consider how you would solve the n-th case if you know the solution to
# the (n-1)-th case.
# In our factorial problem, the base case is factorial(1) = 1, and the
# solution to factorial(n) given factorial(n-1) is:
#       factorial(n) = n * factorial(n - 1)

# Recursive algorithms are popular interview questions and it's not always
# natural to think recursively, but a recursive algorithm is often much more
# elegant than its loop counterpart. Try implementing the factorial function as
# a recursive function.

describe '#factorial_recursion' do
    it 'calculates correct factorials' do
        expect(Interview.factorial_recursion(1)).to eq(1)
        expect(Interview.factorial_recursion(3)).to eq(6)
        expect(Interview.factorial_recursion(5)).to eq(120)
    end

    it 'works recursively' do
        allow(Interview).to receive(:factorial_recursion)
        expect(Interview).to receive(:factorial_recursion).with(3).ordered.and_call_original
        expect(Interview).to receive(:factorial_recursion).with(2).ordered.and_call_original
        expect(Interview).to receive(:factorial_recursion).with(1).ordered.and_return(1)
        expect(Interview.factorial_recursion(3)).to eq(6)
    end
end

# The fibonacci sequence is the sequence generated by adding together the
# two previous values in the sequence. i.e. 1, 1, 2, 3, 5, 8, etc.
describe '#fibonacci_loop' do
    # Write a function that calculates the n-th value of a fibonnaci sequence using
    # a loop.

    it 'calculates correct fibonacci numbers' do
        expect(Interview.fibonacci_loop(1)).to eq(1)
        expect(Interview.fibonacci_loop(2)).to eq(2)
        expect(Interview.fibonacci_loop(5)).to eq(8)
    end

    it 'does not work recursively' do
        allow(Interview).to receive(:fibonacci_loop)
        expect(Interview).to receive(:fibonacci_loop).once
        Interview.fibonacci_loop(2)
    end
end

describe '#fibonacci_recursion' do
    # We can calculate fibonacci numbers in a much more simple way by using
    # recursion.

    it 'calculates correct fibonacci numbers' do
        expect(Interview.fibonacci_recursion(1)).to eq(1)
        expect(Interview.fibonacci_recursion(2)).to eq(2)
        expect(Interview.fibonacci_recursion(5)).to eq(8)
    end

    # Now let's make our recursive method a little more flexible. Our fibonacci
    # method only calcuales values from the fibonacci sequence starting with 1
    # and 1. Let's generalize it to calculate sequences with other starting
    # values. Add two parameters to the fibonacci_recursion method. The first
    # will represent the first value of the sequence, and the second will
    # represent the second value of the sequence. These should be optional
    # parameters with default values = 1

    it 'calculates correct fibonacci numbers given custom starting points' do
        expect(Interview.fibonacci_recursion(0, 2, 5)).to eq(2)
        expect(Interview.fibonacci_recursion(1, 2, 5)).to eq(5)
        expect(Interview.fibonacci_recursion(3, 2, 5)).to eq(12)
    end
end

#### Bonus challenge question ####

# Here is another problem that can be solved recursively:
# How many ways are there to make change for a total amount of N cents given
# unlimited coins with values [c_0, c_1, ..., c_M]?
# For example, how many ways are there to make change for $1.00 with unlimited
# coins with values [1, 5, 10, 25]?

# Write a method, ways_to_make_change(n, coin_values) that will return the
# count of the number of ways to make n out of combinations of coin_values.

describe '#ways_to_make_change' do
    it 'calcuales correct values' do
        expect(Interview.ways_to_make_change(4, [1, 2, 3])).to eq(4)
        expect(Interview.ways_to_make_change(10, [2, 5, 3, 6])).to eq(5)
    end
end
